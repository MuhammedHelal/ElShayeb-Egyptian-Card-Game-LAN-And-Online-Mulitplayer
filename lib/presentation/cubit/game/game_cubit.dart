/// Presentation Layer - Game Cubit
///
/// Manages game state for the UI layer.
/// Delegates all game logic to the GameController and RulesEngine.
library;

import 'dart:developer';

import 'package:easy_localization/easy_localization.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:uuid/uuid.dart';

import '../../../core/core.dart';
import '../../../domain/domain.dart';
import '../../../data/data.dart';
import 'game_state.dart';

export 'game_state.dart';

/// Game mode selection
enum GameMode {
  lan,
  online,
}

/// Game Cubit for managing UI state
class GameCubit extends Cubit<GameUiState> {
  final AudioManager _audioManager;
  final HapticManager _hapticManager;
  final SettingsRepository _settingsRepository;

  GameController? _gameController;
  NetworkManager? _networkManager;
  GameMode _currentMode = GameMode.lan;
  bool _isHosting = false;

  // LAN connection info (for clients to display host IP:PORT)
  String? _connectedHostAddress;
  int? _connectedHostPort;

  // LAN discovery
  bool _isDiscovering = false;
  LanDiscovery? _lanDiscovery;

  GameCubit({
    required AudioManager audioManager,
    required HapticManager hapticManager,
    required SettingsRepository settingsRepository,
  })  : _audioManager = audioManager,
        _hapticManager = hapticManager,
        _settingsRepository = settingsRepository,
        super(const GameUiState());

  /// Current game mode
  GameMode get currentMode => _currentMode;

  /// Discovered LAN rooms
  List<RoomInfo> get discoveredRooms => state.discoveredRooms;

  /// Whether we're currently discovering rooms
  bool get isDiscovering => _isDiscovering;

  /// Host IP address (for LAN mode)
  String? get hostIpAddress => _networkManager?.hostAddress;

  /// Host port (for LAN mode)
  int? get hostPort => _networkManager?.hostPort;

  /// Connection info string for sharing
  String get connectionInfo {
    if (_currentMode == GameMode.lan) {
      // For host, use network manager's address
      if (_isHosting && _networkManager != null) {
        final ip = _networkManager!.hostAddress;
        final port = _networkManager!.hostPort;
        if (ip != null && port != null) {
          return '$ip:$port';
        }
      }
      // For clients, use the stored connection info
      if (_connectedHostAddress != null && _connectedHostPort != null) {
        return '$_connectedHostAddress:$_connectedHostPort';
      }
    }
    return state.roomCode;
  }

  /// Set game mode
  void setGameMode(GameMode mode) {
    _currentMode = mode;
  }

  /// Start discovering LAN rooms
  Future<void> startRoomDiscovery() async {
    stopRoomDiscovery(); // Ensure previous instance is cleaned up

    _isDiscovering = true;
    emit(state.copyWith(discoveredRooms: const [])); // Clear UI list

    _lanDiscovery = LanDiscovery();
    _lanDiscovery!.onRoomsUpdated = (rooms) {
      // Trigger state update
      if (!isClosed) emit(state.copyWith(discoveredRooms: rooms));
    };

    try {
      await _lanDiscovery!.startDiscovery();
    } catch (e) {
      log('Error starting discovery: $e');
      _isDiscovering = false;
    }
  }

  /// Stop discovering rooms
  void stopRoomDiscovery() {
    _isDiscovering = false;
    _lanDiscovery?.stopDiscovery();
    _lanDiscovery?.dispose();
    _lanDiscovery = null;
  }

  /// Create and host a new game
  Future<void> createGame() async {
    stopRoomDiscovery();

    emit(state.copyWith(
      status: LoadingStatus.loading,
      isConnecting: true,
    ));

    try {
      // Create network manager based on mode
      _networkManager = _currentMode == GameMode.lan
          ? LanNetworkManager()
          : OnlineNetworkManager();

      // Create game controller
      final playerId = const Uuid().v4();
      final playerName = _settingsRepository.playerName;
      final avatarId = _settingsRepository.avatarId;

      final player = Player(
        id: playerId,
        name: playerName,
        avatarId: avatarId,
        isHost: true,
      );

      final initialState = GameState.initial(
        roomId: playerId,
        roomCode: '', // Will be generated by controller
        hostId: playerId,
      );

      _gameController = GameController(
        rulesEngine: GameRulesEngine(),
        networkManager: _networkManager!,
        initialState: initialState,
      );

      // Subscribe to events
      _gameController!.addEventListener(_handleGameEvent);
      _gameController!.addStateListener(_handleStateUpdate);

      // Create the game
      await _gameController!.createGame(player);

      // Wait a moment for network to initialize
      await Future.delayed(const Duration(milliseconds: 500));

      _isHosting = true;

      emit(state.copyWith(
        status: LoadingStatus.success,
        isConnecting: false,
        isHost: true,
        localPlayerId: playerId,
        gameState: _gameController!.state,
      ));

      _audioManager.playSoundEffect(SoundEffect.deal);
    } catch (e) {
      emit(state.copyWith(
        status: LoadingStatus.failure,
        error: 'Failed to create game: $e',
        isConnecting: false,
      ));
    }
  }

  /// Join an existing game
  Future<void> joinGame(String hostAddress, int port) async {
    stopRoomDiscovery();

    emit(state.copyWith(
      status: LoadingStatus.loading,
      isConnecting: true,
    ));

    try {
      // Store connection info for LAN mode (so clients can display IP:PORT)
      if (_currentMode == GameMode.lan) {
        _connectedHostAddress = hostAddress;
        _connectedHostPort = port;
      }

      // Create network manager based on mode
      _networkManager = _currentMode == GameMode.lan
          ? LanNetworkManager()
          : OnlineNetworkManager();

      // Create player
      final playerId = const Uuid().v4();
      final playerName = _settingsRepository.playerName;
      final avatarId = _settingsRepository.avatarId;

      final player = Player(
        id: playerId,
        name: playerName,
        avatarId: avatarId,
      );

      final initialState = GameState.initial(
        roomId: '',
        roomCode: '',
        hostId: '',
      ).copyWith(players: [player]); // Add local player to initial dummy state

      _gameController = GameController(
        rulesEngine: GameRulesEngine(),
        networkManager: _networkManager!,
        initialState: initialState,
      );

      // Subscribe to events
      _gameController!.addEventListener(_handleGameEvent);
      _gameController!.addStateListener(_handleStateUpdate);

      // Join the game
      await _gameController!.joinGame(player, hostAddress, port);

      _isHosting = false;

      emit(state.copyWith(
        status: LoadingStatus.success,
        isConnecting: false,
        isHost: false,
        localPlayerId: playerId,
        gameState: _gameController!.state, // Now contains local player
        lastEventMessage: "Waiting for state...",
      ));

      _audioManager.playSoundEffect(SoundEffect.deal);
    } catch (e) {
      emit(state.copyWith(
        status: LoadingStatus.failure,
        error: 'Failed to join game: $e',
        isConnecting: false,
      ));
    }
  }

  /// Join a discovered room directly
  Future<void> joinDiscoveredRoom(RoomInfo room) async {
    await joinGame(room.hostAddress, room.port);
  }

  /// Join game by room code (for online mode)
  Future<void> joinGameByCode(String roomCode) async {
    await joinGame(roomCode, 0);
  }

  /// Start the game (host only)
  Future<void> startGame() async {
    if (_gameController == null || !state.isHost) return;

    await _gameController!.startGame();

    // emit(state.copyWith(showDealAnimation: true));
    // await Future.delayed(const Duration(milliseconds: 1500));
    // emit(state.copyWith(showDealAnimation: false));

    _audioManager.playSoundEffect(SoundEffect.deal);
    _hapticManager.cardDraw();
  }

  // ============ Card Selection Flow ============

  /// Step 1: Player taps another player to draw from
  /// Opens the card selection overlay
  void initiateDrawFrom(String targetPlayerId) {
    if (_gameController == null) return;
    if (!state.isMyTurn) return;
    if (state.drawPhase != DrawPhase.idle) return;

    // Get target player
    final target = state.gameState?.getPlayerById(targetPlayerId);
    if (target == null || target.hand.isEmpty) return;

    emit(state.copyWith(
      drawPhase: DrawPhase.selectingCard,
      currentDrawAction: DrawActionInfo(targetPlayerId: targetPlayerId),
    ));

    _hapticManager.cardTap();
  }

  /// Cancel card selection
  void cancelCardSelection() {
    emit(state.copyWith(
      drawPhase: DrawPhase.idle,
      clearCurrentDrawAction: true,
    ));
  }

  /// Step 2: Player selects a specific card from target's hand
  Future<void> selectCardToDraw(int cardIndex) async {
    if (_gameController == null) return;
    if (state.drawPhase != DrawPhase.selectingCard) return;
    if (state.currentDrawAction == null) return;

    final targetId = state.currentDrawAction!.targetPlayerId;
    final target = state.gameState?.getPlayerById(targetId);
    if (target == null || cardIndex >= target.hand.length) return;

    final drawnCard = target.hand[cardIndex];

    // Update state to show revealing phase
    emit(state.copyWith(
      drawPhase: DrawPhase.revealingCard,
      currentDrawAction: state.currentDrawAction!.copyWith(
        selectedCardIndex: cardIndex,
        drawnCard: drawnCard,
      ),
    ));

    _audioManager.playSoundEffect(SoundEffect.flip);
    _hapticManager.cardDraw();

    // Show the card for 1 second
    await Future.delayed(const Duration(milliseconds: 1200));

    // Check for match
    final localPlayer = state.localPlayer;
    PlayingCard? matchedCard;
    if (localPlayer != null) {
      for (final card in localPlayer.hand) {
        if (card.matchesByRank(drawnCard) && card.id != drawnCard.id) {
          matchedCard = card;
          break;
        }
      }
    }

    if (matchedCard != null) {
      // Show match animation
      emit(state.copyWith(
        drawPhase: DrawPhase.showingMatch,
        currentDrawAction: state.currentDrawAction!.copyWith(
          matchedCard: matchedCard,
          madeMatch: true,
        ),
        matchedCardIds: [drawnCard.id, matchedCard.id],
      ));

      _audioManager.playSoundEffect(SoundEffect.match);
      _hapticManager.matchFound();

      // Show match for 1.5 seconds
      await Future.delayed(const Duration(milliseconds: 1500));
    }

    // Execute the actual draw on the controller
    await _gameController!.drawCard(targetId, cardIndex);

    // Complete the action
    emit(state.copyWith(
      drawPhase: DrawPhase.idle,
      clearCurrentDrawAction: true,
      clearMatchedCardIds: true,
    ));
  }

  /// Legacy method for compatibility - now initiates selection
  Future<void> drawCard(String targetPlayerId) async {
    initiateDrawFrom(targetPlayerId);
  }

  /// Select a card in hand (for UI highlighting)
  void selectCard(int index) {
    emit(state.copyWith(selectedCardIndex: index));
    _hapticManager.cardTap();
  }

  /// Clear card selection
  void clearSelection() {
    emit(state.copyWith(clearSelectedCardIndex: true));
  }

  /// Start new round (host only)
  Future<void> startNewRound() async {
    if (_gameController == null || !state.isHost) return;

    await _gameController!.startNewRound();
    emit(state.copyWith(
      // showDealAnimation: true, // Removed animation
      lastEventMessage: "Round Started ...",
    ));
    _audioManager.playSoundEffect(SoundEffect.deal);
  }

  /// Called when dealing animation completes
  void onDealAnimationComplete() {
    emit(state.copyWith(showDealAnimation: false));
  }

  /// Leave the current game
  Future<void> leaveGame() async {
    await _gameController?.leaveGame();
    _gameController?.dispose();
    _gameController = null;
    _networkManager = null;
    _isHosting = false;
    _connectedHostAddress = null;
    _connectedHostPort = null;

    emit(const GameUiState());
  }

  /// Shuffle the player's own hand
  Future<void> shuffleHand() async {
    if (_gameController == null) return;

    await _gameController!.shuffleHand();
    _hapticManager.cardTap();
  }

  /// Handle game events from controller
  void _handleGameEvent(GameEvent event) {
    // Translate event message using localization key if available
    final localizedMessage = _getLocalizedEventMessage(event);

    // Helper to safely play sound
    void safePlaySound(SoundEffect effect) {
      try {
        _audioManager.playSoundEffect(effect);
      } catch (e) {
        log('Error playing sound effect: $e');
      }
    }

    switch (event.type) {
      case GameEventType.pairRemoved:
        // Match animation is now handled in selectCardToDraw
        emit(state.copyWith(lastEventMessage: localizedMessage));
        break;

      case GameEventType.cardStolen:
        // Only show steal animation for non-active players
        // The active player (stealer) already sees the draw interaction directly
        final stealerId = event.data?['stealerId'] as String?;
        final victimId = event.data?['victimId'] as String?;

        if (stealerId != null &&
            victimId != null &&
            stealerId != state.localPlayerId) {
          // Non-active player: trigger animation
          // Use local time to ensure animation plays immediately regardless of clock skew
          final timestamp = DateTime.now();

          emit(state.copyWith(
            pendingCardStealEvent: CardStealEventInfo(
              stealerId: stealerId,
              victimId: victimId,
              timestamp: timestamp,
            ),
          ));
        }
        // Do not update lastEventMessage for cardStolen events
        // as they might overwrite more important messages like 'Made a pair'
        break;

      case GameEventType.playerFinished:
        safePlaySound(SoundEffect.win);
        _hapticManager.victory();
        emit(state.copyWith(lastEventMessage: localizedMessage));
        break;

      case GameEventType.roundEnded:
        final localPlayer = state.localPlayer;
        if (localPlayer?.isShayeb == true) {
          safePlaySound(SoundEffect.lose);
          _hapticManager.defeat();
        } else {
          safePlaySound(SoundEffect.win);
          _hapticManager.victory();
        }
        emit(state.copyWith(lastEventMessage: localizedMessage));
        break;

      case GameEventType.error:
        emit(state.copyWith(error: localizedMessage));
        break;

      default:
        emit(state.copyWith(lastEventMessage: localizedMessage));
    }
  }

  /// Get localized message from event
  String _getLocalizedEventMessage(GameEvent event) {
    // If no message key, return fallback message
    if (event.messageKey == null) {
      return event.message;
    }

    try {
      // Use the translation key with parameters
      final key = event.messageKey!;
      final params = event.messageParams;

      if (params != null && params.isNotEmpty) {
        return key.tr(namedArgs: params);
      } else {
        return key.tr();
      }
    } catch (e) {
      log('Error translating event message: $e');
      // Fallback to the English message
      return event.message;
    }
  }

  /// Clear the pending card steal animation after it completes
  void onStealAnimationComplete() {
    emit(state.copyWith(clearPendingCardStealEvent: true));
  }

  /// Handle state updates from controller
  void _handleStateUpdate(GameState gameState) {
    emit(state.copyWith(
      gameState: gameState,
      status: LoadingStatus.success,
      lastEventMessage: gameState.lastAction,
      isConnecting: false,
    ));
  }

  @override
  Future<void> close() {
    stopRoomDiscovery();
    _gameController?.dispose();
    _networkManager?.dispose();
    return super.close();
  }
}
