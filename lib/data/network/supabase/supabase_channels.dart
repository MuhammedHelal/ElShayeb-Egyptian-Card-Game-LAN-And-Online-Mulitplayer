/// Data Layer - Supabase Channels
///
/// Manages Supabase Realtime channel subscriptions and event broadcasting.
library;

import 'dart:async';
import 'dart:developer';

import 'package:supabase_flutter/supabase_flutter.dart';

import '../connection_state.dart';
import '../online_events.dart';
import 'supabase_mappers.dart';

class SupabaseChannels {
  final SupabaseClient _client;

  RealtimeChannel? _gameChannel;
  StreamSubscription? _statusSubscription;

  final _eventController = StreamController<OnlineGameEvent>.broadcast();
  final _connectionStateController =
      StreamController<OnlineConnectionState>.broadcast();

  SupabaseChannels(this._client);

  Stream<OnlineGameEvent> get events => _eventController.stream;
  Stream<OnlineConnectionState> get connectionState =>
      _connectionStateController.stream;

  /// Subscribe to a game room channel
  Future<void> subscribeToRoom(
      String roomId, String userId, Map<String, dynamic> playerData) async {
    if (_gameChannel != null) {
      await unsubscribe();
    }

    try {
      _connectionStateController.add(const OnlineConnectionState.connecting());

      final channelName = 'room:$roomId';
      _gameChannel = _client.channel(channelName);

      // Subscribe to broadcast events (game actions)
      _gameChannel!.onBroadcast(
        event: 'game_event',
        callback: (payload) {
          log('Supabase Incoming Broadcast: $payload');
          try {
            final event = SupabaseMappers.toOnlineEvent(payload);
            log('Parsed Event: ${event.type}');
            _eventController.add(event);
          } catch (e, stack) {
            log('Error parsing broadcast event: $e');
            log('Stack trace: $stack');
          }
        },
      );

      // Subscribe to presence (joining/leaving)
      _gameChannel!.onPresenceSync((payload) {
        log('Presence Sync: $payload');
        // Presence sync shows all currently connected users
        // We can use this to validate and sync initial player list
        final presences = _gameChannel!.presenceState();
        log('Current Presences: $presences');

        for (final presence in presences) {
          final presenceMap =
              (presence as dynamic).payload as Map<String, dynamic>;

          // Reuse the logic to extract ID
          final gamePlayerId = presenceMap['id'] as String?;
          final authUserId = presenceMap['player_id'] as String?;
          final effectiveId = gamePlayerId ?? authUserId;

          if (effectiveId == null) continue;

          _eventController.add(
            GenericGameEvent(
              type: OnlineEventTypes.playerJoined,
              data: {
                'id': effectiveId,
                'name': presenceMap['name'] ?? 'Player',
                'avatarId': presenceMap['avatarId'] ?? 'avatar_1',
                'isHost': presenceMap['isHost'] ?? false,
                ...Map<String, dynamic>.from(presenceMap),
              },
              senderId: effectiveId,
              timestamp: DateTime.now(),
            ),
          );
        }
      });

      _gameChannel!.onPresenceJoin((payload) {
        log('Presence Join: ${payload.newPresences}');
        // Map to PlayerJoined
        final newPresences = payload.newPresences;
        for (final presence in newPresences) {
          final presenceMap = presence.payload;

          // CRITICAL FIX: Prefer Game Player ID ('id') over Supabase Auth ID ('player_id')
          // 'player_id' is the Auth UUID, 'id' is the Game Player UUID generated by GameCubit.
          // We must use 'id' to match local player checks and GameState consistency.
          final gamePlayerId = presenceMap['id'] as String?;
          final authUserId = presenceMap['player_id'] as String?;

          final effectiveId = gamePlayerId ?? authUserId;

          if (effectiveId == null) continue;

          _eventController.add(
            GenericGameEvent(
              type: OnlineEventTypes.playerJoined,
              data: {
                'id': effectiveId, // Use the Game Player ID
                'name': presenceMap['name'] ?? 'Player',
                'avatarId': presenceMap['avatarId'] ?? 'avatar_1',
                'isHost': presenceMap['isHost'] ?? false,
                ...Map<String, dynamic>.from(presenceMap),
              },
              senderId: effectiveId, // Sender ID must match the Game Player ID
              timestamp: DateTime.now(),
            ),
          );
        }
      });

      _gameChannel!.onPresenceLeave((payload) {
        log('Presence Leave: ${payload.leftPresences}');
        final leftPresences = payload.leftPresences;
        for (final presence in leftPresences) {
          final presenceMap = presence.payload;

          final gamePlayerId = presenceMap['id'] as String?;
          final authUserId = presenceMap['player_id'] as String?;

          final effectiveId = gamePlayerId ?? authUserId;

          if (effectiveId == null) continue;

          _eventController.add(
            GenericGameEvent(
              type: OnlineEventTypes.playerLeft,
              data: Map<String, dynamic>.from(presenceMap),
              senderId: effectiveId,
              timestamp: DateTime.now(),
            ),
          );
        }
      });

      // Subscribe to Postgres Changes (Game State Updates)
      _gameChannel!.onPostgresChanges(
        event: PostgresChangeEvent.update,
        schema: 'public',
        table: 'rooms',
        filter: PostgresChangeFilter(
          type: PostgresChangeFilterType.eq,
          column: 'room_code',
          value: roomId,
        ),
        callback: (payload) {
          log('Supabase DB Change: $payload');
          final newRecord = payload.newRecord;
          if (newRecord.containsKey('game_state')) {
            final stateData = newRecord['game_state'] as Map<String, dynamic>;
            _eventController.add(GenericGameEvent(
              type: OnlineEventTypes.stateSync,
              data: {'state': stateData},
              timestamp: DateTime.now(),
            ));
          }
        },
      );

      // Subscribe with status callback
      final completer = Completer<void>();

      _gameChannel!.subscribe((status, error) {
        log('Supabase channel status: $status, error: $error');

        if (status == RealtimeSubscribeStatus.subscribed) {
          _connectionStateController
              .add(const OnlineConnectionState.connected());
          if (!completer.isCompleted) {
            completer.complete();
          }
        } else if (status == RealtimeSubscribeStatus.closed) {
          _connectionStateController
              .add(const OnlineConnectionState.disconnected());
          if (!completer.isCompleted) {
            completer.completeError('Channel closed');
          }
        } else if (status == RealtimeSubscribeStatus.channelError) {
          final errorMsg = error?.toString() ?? 'Channel error';
          _connectionStateController.add(OnlineConnectionState.error(errorMsg));
          if (!completer.isCompleted) {
            completer.completeError(errorMsg);
          }
        }
      });

      // Wait for subscription to complete with timeout
      await completer.future.timeout(
        const Duration(seconds: 10),
        onTimeout: () {
          throw TimeoutException(
              'Failed to subscribe to channel within 10 seconds');
        },
      );

      // Track presence after successful subscription
      await _gameChannel!.track({
        'player_id': userId,
        'online_at': DateTime.now().toIso8601String(),
        ...playerData,
      });
    } catch (e) {
      log('Error subscribing to room: $e');
      _connectionStateController.add(OnlineConnectionState.error(e.toString()));
      rethrow;
    }
  }

  /// Broadcast an event to the room
  Future<void> broadcastEvent(OnlineGameEvent event) async {
    if (_gameChannel == null) return;

    await _gameChannel!.sendBroadcastMessage(
      event: 'game_event',
      payload: event.toJson(),
    );
  }

  /// Unsubscribe from current channel
  Future<void> unsubscribe() async {
    if (_gameChannel != null) {
      await _client.removeChannel(_gameChannel!);
      _gameChannel = null;
      _connectionStateController
          .add(const OnlineConnectionState.disconnected());
    }
  }

  void dispose() {
    unsubscribe();
    _eventController.close();
    _connectionStateController.close();
    _statusSubscription?.cancel();
  }
}
